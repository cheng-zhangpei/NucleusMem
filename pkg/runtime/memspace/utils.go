package memspace

import (
	"encoding/binary"
	"errors"
)

// ZonePrefix defines the zone prefix type (single byte)
type ZonePrefix byte

const (
	// Define prefix constants for four core zones
	// Using hexadecimal values resembles low-level systems; 0x7a='z' (Zone) could also be used,
	// but simple numeric values are chosen here for clarity

	ZoneMemory  ZonePrefix = 0x01 // Memory Zone (M): stores actual Context data
	ZoneTask    ZonePrefix = 0x02 // Task Zone (T): stores DAGs and workflow states
	ZoneSummary ZonePrefix = 0x03 // Summary Zone (S): stores snapshots generated by Workers
	ZoneComm    ZonePrefix = 0x04 // Communication Zone (C): stores Pub/Sub messages
)

// String method provides human-friendly output for logging
func (z ZonePrefix) String() string {
	switch z {
	case ZoneMemory:
		return "MemoryZone"
	case ZoneTask:
		return "TaskZone"
	case ZoneSummary:
		return "SummaryZone"
	case ZoneComm:
		return "CommZone"
	default:
		return "UnknownZone"
	}
}

// EncodeKey KeyEncoder converts logical keys into underlying storage keys
// Structure: [Zone 1byte][MemSpaceID 8bytes][UserKey Nbytes]
func EncodeKey(zone ZonePrefix, memSpaceID uint64, userKey []byte) []byte {
	// Pre-allocate capacity: 1 + 8 + len(userKey)
	buf := make([]byte, 0, 1+8+len(userKey))

	// 1. Write Zone prefix
	buf = append(buf, byte(zone))

	// 2. Write MemSpaceID (big-endian for ordered storage)
	idBytes := make([]byte, 8)
	binary.BigEndian.PutUint64(idBytes, memSpaceID)
	buf = append(buf, idBytes...)

	// 3. Append the user's actual key bytes
	buf = append(buf, userKey...)

	return buf
}

// DecodeKey KeyDecoder parses underlying storage keys back into logical components
func DecodeKey(rawKey []byte) (ZonePrefix, uint64, []byte, error) {
	// Minimum length check (1 byte Zone + 8 bytes ID)
	if len(rawKey) < 9 {
		return 0, 0, nil, errors.New("invalid key length: too short")
	}

	// 1. Parse Zone prefix
	zone := ZonePrefix(rawKey[0])

	// 2. Parse MemSpaceID
	memSpaceID := binary.BigEndian.Uint64(rawKey[1:9])

	// 3. Extract UserKey
	// Note: This returns a slice reference; copy if mutation is needed later
	userKey := rawKey[9:]

	return zone, memSpaceID, userKey, nil
}

// GetScanPrefix generates a prefix for scanning all keys within a specific zone of a MemSpace
// Example: Scan all "Task" entries under MemSpace ID 100
func GetScanPrefix(zone ZonePrefix, memSpaceID uint64) []byte {
	buf := make([]byte, 0, 9)
	buf = append(buf, byte(zone))

	idBytes := make([]byte, 8)
	binary.BigEndian.PutUint64(idBytes, memSpaceID)
	buf = append(buf, idBytes...)

	return buf
}
